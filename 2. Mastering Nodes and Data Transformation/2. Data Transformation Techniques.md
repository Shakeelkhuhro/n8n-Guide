# Data Transformation Techniques: Expressions and JavaScript

Data transformation is a crucial aspect of workflow automation. n8n provides powerful tools for manipulating data as it flows through your workflows. This lesson will focus on two key techniques: using expressions and JavaScript code within nodes. Mastering these techniques will allow you to handle a wide range of data manipulation tasks, from simple formatting to complex calculations and conditional logic.

## Understanding n8n Expressions

n8n expressions are a powerful way to access and manipulate data within your workflow. They allow you to reference data from previous nodes, perform calculations, and apply conditional logic without writing full JavaScript code. Expressions are evaluated at runtime, meaning their values are dynamically determined based on the data flowing through the workflow.

### Syntax and Structure

n8n expressions use a specific syntax to access data and perform operations. The basic structure involves using double curly braces `{{ ... }}` to enclose the expression. Inside the braces, you can reference data from previous nodes using the `$node` object, followed by the node name and the data you want to access.

For example, to access the `body` property from a node named "HTTP Request", you would use the following expression:

```

{{ \$node\["HTTP Request"].json.body }}

```

Let's break down this expression:

- **$node**: This is a global object in n8n that allows you to access data from other nodes.
- **["HTTP Request"]**: This specifies the name of the node you want to access. Note that the node name is enclosed in square brackets and quotes.
- **.json**: This indicates that you want to access the JSON data returned by the node. If the node returns data in a different format (e.g., XML), you would use the appropriate property (e.g., `.xml`).
- **.body**: This specifies the specific property you want to access within the JSON data.

### Accessing Data from Previous Nodes

The `$node` object is the key to accessing data from previous nodes in your workflow. You can use it to retrieve data from any node that has already executed.

**Example**:

Suppose you have a workflow with two nodes:

- **HTTP Request**: This node makes an API call and returns a JSON response containing user data. Let's say the node is named `"Get User"`.
- **Set**: This node is used to set a new property based on the data from the "Get User" node.

To access the user's email address from the "Get User" node in the "Set" node, you would use the following expression:

```

{{ \$node\["Get User"].json.email }}

```

This expression retrieves the value of the `email` property from the JSON data returned by the "Get User" node.

**Advanced Example**:

If the "Get User" node returns an array of user objects, and you want to access the email address of the first user in the array, you would use the following expression:

```

{{ \$node\["Get User"].json\[0].email }}

```

The `[0]` index specifies that you want to access the first element in the array.

### Operators and Functions

n8n expressions support a wide range of operators and functions for manipulating data. These include:

- **Arithmetic operators**: `+`, `-`, `*`, `/`, `%` (addition, subtraction, multiplication, division, modulo)
- **Comparison operators**: `==`, `!=`, `>`, `<`, `>=`, `<=`
- **Logical operators**: `&&`, `||`, `!`
- **String functions**: `toUpperCase()`, `toLowerCase()`, `substring()`, `replace()`
- **Math functions**: `Math.round()`, `Math.floor()`, `Math.ceil()`, `Math.random()`
- **Date functions**: `new Date()`, `toISOString()`, `toLocaleDateString()`

**Example**:

Suppose you want to calculate the total price of an item after applying a discount. You have the original price and the discount percentage in the data from a previous node. You can use the following expression to calculate the discounted price:

```

{{ \$node\["Get Item"].json.price \* (1 - (\$node\["Get Item"].json.discount / 100)) }}

```

**Example**:

Suppose you want to convert a string to uppercase. You can use the `toUpperCase()` function:

```

{{ \$node\["Get String"].json.myString.toUpperCase() }}

```

### Conditional Logic

n8n expressions also support conditional logic using the ternary operator `condition ? valueIfTrue : valueIfFalse`. This allows you to perform different actions based on whether a condition is true or false.

**Example**:

Suppose you want to set a different message based on whether a user is a premium member or not. You can use the following expression:

```

{{ \$node\["Get User"].json.isPremium ? "Welcome, premium member!" : "Welcome!" }}

```

## Exercises

- **Concatenate strings**: Use data from two previous nodes to create a full name. Assume one node provides the first name and the other provides the last name.
- **Calculate age**: Given a birthdate from a previous node, calculate the age of the user.
- **Format a number**: Format a number from a previous node to two decimal places.
- **Check if a string contains a substring**: Check if a string from a previous node contains a specific substring. Return "Yes" if it does, and "No" if it doesn't.

## Using JavaScript Code in Function Nodes

While n8n expressions are powerful, they have limitations when it comes to complex data manipulation. For more advanced tasks, you can use JavaScript code within Function nodes. Function nodes allow you to write arbitrary JavaScript code to transform data, perform calculations, and interact with external APIs.

### Structure of a Function Node

A Function node in n8n executes JavaScript code. The code you write in a Function node receives an array of items as input. Each item in the array represents a data object from the previous node. Your code should process these items and return a new array of items as output.

The basic structure of a Function node is as follows:

```javascript
return items.map(item => {
  // Your code here
  return item;
});
```

Let's break down this code:

* **items**: This is an array of data objects from the previous node.
* **items.map()**: This is a JavaScript method that iterates over each item in the `items` array and applies a function to it.
* **item => { ... }**: This is an arrow function that takes a single item as input and returns a modified item as output.
* **return item**: This returns the modified item to the `map()` method.

### Accessing Data within a Function Node

Within a Function node, you can access the data from the previous node using the `item.json` property. This property contains the JSON data associated with the current item.

**Example**:

Suppose you have a workflow where a previous node returns a list of products with their names and prices. You want to add a new property to each product object that indicates whether the product is expensive (price > 100).

```javascript
return items.map(item => {
  if (item.json.price > 100) {
    item.json.isExpensive = true;
  } else {
    item.json.isExpensive = false;
  }
  return item;
});
```

### Performing Complex Data Transformations

Function nodes are particularly useful for performing complex data transformations that are difficult or impossible to achieve with n8n expressions alone.

**Example**:

Suppose you have a workflow where a previous node returns a string containing a comma-separated list of values. You want to convert this string into an array of values.

```javascript
return items.map(item => {
  item.json.values = item.json.myString.split(",");
  return item;
});
```

**Example**:

Suppose you want to merge data from multiple items into a single item. This is a common scenario when dealing with data that is split across multiple items.

```javascript
// Assuming you want to merge all items into the first item
if (items.length > 1) {
  for (let i = 1; i < items.length; i++) {
    // Merge the data from the current item into the first item
    Object.assign(items[0].json, items[i].json);
  }
  // Remove all items except the first one
  items = [items[0]];
}

return items;
```

### Using External Libraries

Function nodes allow you to use external JavaScript libraries to perform more specialized data transformations. To use an external library, you need to install it using npm and then import it into your Function node. However, n8n's Function node environment has some limitations regarding external libraries. It's generally recommended to stick to native JavaScript functions and methods whenever possible.

### Error Handling

When writing JavaScript code in Function nodes, it's important to handle errors gracefully. You can use try...catch blocks to catch errors and prevent your workflow from crashing.

**Example**:

```javascript
return items.map(item => {
  try {
    // Your code here
    item.json.result = JSON.parse(item.json.myString);
  } catch (error) {
    // Handle the error
    item.json.error = error.message;
  }
  return item;
});
```

## Exercises

* **Convert a date format**: Convert a date string from one format to another. (e.g., from "YYYY-MM-DD" to "MM/DD/YYYY")
* **Calculate the difference between two dates**: Calculate the number of days between two dates.
* **Filter an array of objects**: Filter an array of objects based on a specific criteria. (e.g., filter out all products with a price less than 50)
* **Sort an array of objects**: Sort an array of objects based on a specific property. (e.g., sort products by price in ascending order)

## Summary and Next Steps

In this lesson, you learned about two powerful techniques for data transformation in n8n: expressions and JavaScript code within Function nodes. Expressions are useful for simple data manipulation tasks, while Function nodes provide more flexibility for complex transformations. By mastering these techniques, you'll be able to handle a wide range of data manipulation scenarios in your workflows.

In the next lesson, you will learn about looping and iteration, which will allow you to process lists of data efficiently. You'll learn how to use the Item Lists node to split data into individual items and how to use the Merge node to combine data from multiple items.
